# CHAPTER 7 Function decorators and closures 
# 第七章 函数装饰器和必包

*There’s been a number of complaints about the choice of the name “decorator” for this feature. The major one is that the name is not consistent with its use in the GoF book[1]. The name decorator probably owes more to its use in the compiler area — a syntax tree is walked and annotated.— PEP 318 — Decorators for Functions and Methods*  

[1]. That’s the 1995 “Design Patterns” book by the so-called Gang of Four.  

Function decorators let us “mark” functions in the source code to enhance their behavior is some way. This is powerful stuff, but mastering it requires understanding closures.  
One of the newest reserved keywords in Python is `nonlocal`, introduced in Python 3.0. You can have a profitable life as a Python programmer without ever using it if you adhere to a strict regimen of class-centered object orientation. However, if you want to imple‐ ment your own function decorators, you must know closures inside out, and then the need for nonlocal becomes obvious.  
Aside from their application in decorators, closures are also essential for effective asyn‐ chronous programming with callbacks, and for coding in a functional style whenever it makes sense.  
The end goal of this chapter is to explain exactly how function decorators work, from the simplest registration decorators to the rather more complicated parametrized ones. However, before we reach that goal we need to cover:  

• How Python evaluates decorator syntax  
• How Python decides whether a variable is local  
• Why closures exist and how they work  

• What problem is solved by nonlocal  



With this grounding we can tackle further decorator topics:  
• Implementing a well-behaved decorator  
• Interesting decorators in the standard library • Implementing a parametrized decorator  
We start with a very basic introduction to decorators, and then proceed with the rest of the items above [2]. 

[2]: The next section is named after the academic tradition of naming introductory courses like “Calculus 101”. Function decorators are way easier than calculus, though.

## Decorators 101A decorator is a callable that takes another function as argument (the decorated func‐ tion) [3]. The decorator may perform some processing with the decorated function, and returns it or replaces it with another function or callable object.In other words, this code:  

[3]: Python also supports class decorators. They are covered in Chapter 21.  

```python@decoratedef target():print('running target()')Has the same effect as writing this:def target():print('running target()')    target = decorate(target)```

The end result is the same: at the end of either of these snippets, the target name does not necessarily refer to the original target function, but to whatever function is re‐ turned by `decorate(target)`.  
To confirm that the decorated function is replaced, see the console session in Example 7-1.  

*Example 7-1. A decorator usually replaces a function with a different one.*  

```python>>> def deco(func):
...     def inner():...			print('running inner()')... return inner #1
>>> @deco... def target(): #2... print('running target()')...>>> target() #3running inner()>>> target #4<function deco.<locals>.inner at 0x10063b598>
```
1:	deco returns its inner function object. 2: target is decorated by deco.3:	Invoking the decorated target actually runs inner. 
4: Inspection reveals that target is a now a reference to inner.  

Strictly speaking, decorators are just syntactic sugar. As we just saw, you can always simply call a decorator like any regular callable, passing another function. Sometimes that is actually convenient, especially when doing `metaprogramming` — changing pro‐ gram behavior at run-time.   

To summarize: the first crucial fact about decorators is that they have the power to replace the decorated function with a different one. The second crucial fact is that they are executed immediately when a module is loaded. This is explained next.  

## When Python executes decoratorsA key feature of decorators is that they run right after the decorated function is defined. That is usually at import time, i.e. when a module is loaded by Python. Consider regis tration.py in Example 7-2.  
*Example 7-2. The registration.py module* 

```python
registry = []
def register(func):	  print('running register(%s)' % func) registry.append(func)	  return func
	  @registerdef f1():    print('running f1()')
    @registerdef f2():    print('running f2()')
    def f3():    print('running f3()')
def main():    print('running main()') print('registry ->', registry) f1()    f2()    f3()
    if __name__=='__main__': 
    main()
```1: registry will hold references to functions decorated by @register 
2: register takes a function as argument.  
3: Display what function is being decorated, for demonstration. 
4: Include func in registry.  
5: Return func: we must return a function, here we return the same received as argument.  
6: f1 and f2 are decorated by @register.  
7: f3 is not decorated.  
8: `main` displays the registry, then calls `f1()`, `f2()` and `f3()`.  

9: `main()` is only invoked if registration.py runs as a script.  

The output of running `registration.py` as a script looks like this:  

```python$ python3 registration.pyrunning register(<function f1 at 0x100631bf8>)running register(<function f2 at 0x100631c80>)running main()registry -> [<function f1 at 0x100631bf8>, <function f2 at 0x100631c80>] running f1()running f2()running f3()
```
Note that `register` runs (twice) before any other function in the module. When reg ister is called, it receives as argument the function object being decorated, eg. `<func tion f1 at 0x100631bf8>`.  

After the module is loaded, the `registry` holds references to the two decorated func‐ tions: `f1` and `f2`. These functions, as well as `f3`, are only executed when explicitly called by `main`.  

If `registration.py` is imported (and not run as a script), the output is this:  

```python
>>> import registrationrunning register(<function f1 at 0x10063b1e0>) running register(<function f2 at 0x10063b268>)
```
At this time, if you look at the `registry`, here is what you get:

```python
>>> registration.registry[<function f1 at 0x10063b1e0>, <function f2 at 0x10063b268>]
```


The main point of Example 7-2 is to emphasize that function decorators are executed as soon as the module is imported, but the decorated functions only run when they are explicitly invoked. This highlights the difference between what Pythonistas call `import time` and `run time`.  
Considering how decorators are commonly employed in real code, Example 7-2 is un‐ usual in two ways:  

• The decorator function is defined in the same module as the decorated functions. A real decorator is usually defined in one module and applied to functions in other modules.  
• The register decorator returns the same function passed as argument. In practice, most decorators define an inner function and return it.  

Even though the register decorator in Example 7-2 returns the decorated function unchanged, that technique is not useless. Similar decorators are used in many Python Web frameworks to add functions to some central registry, for example, a registry map‐ ping URL patterns to functions that generate HTTP responses. Such registration dec‐ orators may or may not change the decorated function. The next section shows a prac‐ tical example.  

## Decorator-enhanced Strategy patternA registration decorator is a good enhancement to the e-commerce promotional dis‐ count from “Case study: refactoring Strategy” on page 168.  
Recall that our main issue with Example 6-6 is the repetition of the function names in their definitions and then in the promos list used by the `best_promo` function to deter‐ mine the highest discount applicable. The repetition is problematic because someone may add a new promotional strategy function and forget to manually add it to the promos list — in which case `best_promo` will silently ignore the new strategy, introducing a subtle bug in the system. Example 6-8 solves this problem with a registration decorator.  



